#!/usr/bin/env python

################################################################################
import numpy as np
import sympy as sp
from sympy.physics.wigner import gaunt, wigner_3j

from itertools import product
import time

# import sys, logging
# logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)

################################################################################
SQRT2 = np.sqrt(2)
################################################################################
def sph_u_c2r(l):
    '''
    Set up transformation matrix complex->real spherical harmonics.

    please refer to:
    https://en.wikipedia.org/wiki/Spherical_harmonics#Real_form
    U_R2C is the conjugate transpose of U_C2R
    '''

    # A strange bug:
    # https://stackoverflow.com/questions/9887549/negative-exponent-with-numpy-array-operand/42776488
    l = int(l)

    TLP1 = 2 * l + 1
    U_C2R = np.zeros((TLP1, TLP1), dtype=complex)

    sqrt2inv = 1.0 / np.sqrt(2.0)
    for ii in range(TLP1):
        M = ii - l
        if (M < 0):
            U_C2R[ii, ii] = 1j * sqrt2inv
            U_C2R[ii, -(ii+1)] = -1j * (-1)**M * sqrt2inv
        if (M == 0):
            U_C2R[ii, ii] = 1.0
        if (M > 0):
            U_C2R[ii, -(ii+1)] = sqrt2inv
            U_C2R[ii, ii] = (-1)**M * sqrt2inv

    return U_C2R


def gaunt_c2r(l1, l2, l3, m1, m2, m3):
    '''
    Convert Gaunt coefficients defined on complex SPH to Gaunt coefficients on
    real SPH.
    '''

    SQRT2 = np.sqrt(2.0)
    U = []
    M = []
    for m in [m1, m2, m3]:
      if m < 0:
        U.append([1j/SQRT2, -(-1)**(-m) * 1j/SQRT2])
        M.append([m, -m])
      elif m > 0:
        U.append([1/SQRT2,  (-1)**m /SQRT2])
        M.append([-m, m])
      else:
        U.append([1,])
        M.append([0,])

    U  = np.prod(
            np.array(np.meshgrid(U[0], U[1], U[2])).reshape((3, -1)).T,
            axis=1)
    M  = np.array(np.meshgrid(M[0], M[1], M[2])).reshape((3, -1)).T
    g1 = np.array([float(sp.N(gaunt(l1, l2, l3, *m))) for m in M])
    g2 = np.sum(U * g1)

    return g2


def gaunt3j(l1, l2, l3, m1, m2, m3):
    '''
    Gaunt coefficients from Wigner-3j symbols
    '''


    return sp.N(
      np.sqrt((2*l1+1)*(2*l2+1)*(2*l3+1)/np.pi/4) * \
      wigner_3j(l1, l2, l3, 0, 0, 0) *\
      wigner_3j(l1, l2, l3, m1, m2, m3)
    )


def uniq_perm(l1, l2, l3, m1, m2, m3):
    """
    return unique permutation of (l1, l2, l3, m1, m2, m3)
    """

    ii = np.argsort([l1, l2, l3])
    l4, l5, l6 = np.array([l1, l2, l3])[ii]
    m4, m5, m6 = np.array([m1, m2, m3])[ii]

    if l4 == l5 == l6:
        m4, m5, m6 = sorted([m4, m5, m6])
    elif l4 == l5 < l6:
        if m4 > m5:
            m4, m5 = m5, m4
    elif l4 < l5 == l6:
        if m5 > m6:
            m5, m6 = m6, m5
    else:
        pass
    return l4, l5, l6, m4, m5, m6


################################################################################
# Maximum l in Gaunt coefficients
GAUNT_LMAX        = 7
# Gaunt coefficients by integrating three *complex* spherical harmonics
GAUNT_COEFF_DATA1 = {}
# Gaunt coefficients by integrating three *real* spherical harmonics
GAUNT_COEFF_DATA2 = {}
# unitary matrix for transforming complex to real spherical harmonics.
U2R_MAT           = [sph_u_c2r(l) for l in range(GAUNT_LMAX)]

################################################################################

out = open('gaunt.py', 'w+')
out.write('#!/usr/bin/env python\n')
out.write('# Generated by gen_gaunt_data.py\n\n')
out.write('import numpy as np\n\n')
out.write(f'GAUNT_LMAX = {GAUNT_LMAX}\n\n')
out.write('# (l1, l2, l3, m1, m2, m3) : G\n')
out.write('GAUNT_COEFF_DATA1 = {\n')

ngc = 0
for l1 in range(GAUNT_LMAX):
  for l2 in range(GAUNT_LMAX):
    for l3 in range(GAUNT_LMAX):

      # zero for odd sum of ls
      L = l1 + l2 + l3
      if L % 2 != 0: continue

      # zero if the triangle inequality not fulfilled
      a, b, c = sorted([l1, l2, l3])
      if a + b < c: continue

      for m1 in range(-l1, l1+1):
        for m2 in range(-l2, l2+1):
          for m3 in range(-l3, l3+1):
            # zero if sum of ms not zero
            m = m1 + m2 + m3
            if m != 0: continue

            l4, l5, l6, m4, m5, m6 = uniq_perm(l1, l2, l3, m1, m2, m3)
            k  = (l4, l5, l6, m4, m5, m6)
            km = (l4, l5, l6,-m4,-m5,-m6)

            if k in GAUNT_COEFF_DATA1 or km in GAUNT_COEFF_DATA1: continue

            ngc += 1

            # somehow, gaunt(l4, l5, l6, m4, m5, m6) return complex values
            # when l too large
            # g = sp.N(gaunt(l4, l5, l6, m4, m5, m6))
            # v = float(g)

            # resort to wigner-3j method
            g = gaunt3j(l4, l5, l6, m4, m5, m6)
            v = float(g)

            GAUNT_COEFF_DATA1[k] = v
            out.write('   ({:d},{:2d},{:2d}, {:2d},{:2d},{:2d})'.format(*k) + f' : {v:20.16f},')
            print('Gaunt1({:d},{:2d},{:2d},{:2d},{:2d},{:2d})'.format(*k) + f' = {v:20.16f}')
            if ngc % 3 == 0:
              out.write('\n')

out.write('}')
out.write('\n\n')

################################################################################
def GauntTable(l1=0, l2=0, l3=0, m1=0, m2=0, m3=0, real=True):
    """
    Get Gaunt coefficients from the pre-calculated table.

    If "real = True", the the Gaunt coefficients are defined as the integral
    over three *real* spherical harmonics.
    """

    lmax = np.max([l1, l2, l3])
    assert lmax < GAUNT_LMAX, "Exceeding maximum l in Gaunt Table!"

    # # invariant under any permutation
    # l_sort_ind = np.argsort([l1, l2, l3])
    # l4, l5, l6 = np.array([l1, l2, l3])[l_sort_ind]
    # m4, m5, m6 = np.array([m1, m2, m3])[l_sort_ind]
    # k = (l4, l5, l6, m4, m5, m6)

    k = uniq_perm(l1, l2, l3, m1, m2, m3)

    if real:
        g = 0.0 if k not in GAUNT_COEFF_DATA2 else GAUNT_COEFF_DATA2[k]
    else:
        l4, l5, l6, m4, m5, m6 = k
        # invariant under space reflection
        km = (l4, l5, l6, -m4, -m5, -m6)

        if k in GAUNT_COEFF_DATA1:
            g = GAUNT_COEFF_DATA1[k]
        elif km in GAUNT_COEFF_DATA1:
            g = GAUNT_COEFF_DATA1[km]
        else:
            g = 0.0

    return g

################################################################################
out.write('GAUNT_COEFF_DATA2 = {\n')

ngc = 0
for l1 in range(GAUNT_LMAX):
  for l2 in range(GAUNT_LMAX):
    for l3 in range(GAUNT_LMAX):

      # zero for odd sum of ls
      L = l1 + l2 + l3
      if L % 2 != 0: continue

      # zero if the triangle inequality not fulfilled
      l4, l5, l6 = sorted([l1, l2, l3])
      if l4 + l5 < l6: continue

      # mijk = np.mgrid[-l4:l4+1, -l5:l5+1, -l6:l6+1].reshape(3, -1).T
      # mijk = mijk[np.sum(mijk, axis=1)==0]

      for m1 in range(-l1, l1+1):
        for m2 in range(-l2, l2+1):
          for m3 in range(-l3, l3+1):

            # zero if all m's are < 0
            if max(m1, m2, m3) < 0: continue
            if min(m1, m2, m3) > 0 and (m1 + m2 + m3) % 2 != 0: continue

            k1 = uniq_perm(l1, l2, l3, m1, m2, m3)
            l4, l5, l6, m4, m5, m6 = k1

            if k1 in GAUNT_COEFF_DATA2: continue

            t0 = time.time()
            U = []
            M = []
            for m in [m4, m5, m6]:
              if m < 0:
                U.append([1j/SQRT2, -(-1)**(-m) * 1j/SQRT2])
                M.append([m, -m])
              elif m > 0:
                U.append([1/SQRT2,  (-1)**m /SQRT2])
                M.append([-m, m])
              else:
                U.append([1,])
                M.append([0,])

            U  = np.prod(
                    np.array(np.meshgrid(U[0], U[1], U[2])).reshape((3, -1)).T,
                    axis=1)
            M  = np.array(np.meshgrid(M[0], M[1], M[2])).reshape((3, -1)).T
            g1 = np.array([GauntTable(l4, l5, l6, *m, real=False) for m in M])
            g2 = np.sum(U * g1)
            t1 = time.time()

            # g2 = 0
            # t0 = time.time()
            # for ms in mijk:
            #   mi, mj, mk = ms
            #   # g1 = float(gaunt3j(l4, l5, l6, mi, mj, mk))
            #   g1 = GauntTable(l4, l5, l6, mi, mj, mk, real=False)
            #   g2 += U2R_MAT[l4][m4+l4, mi+l4] * U2R_MAT[l5][m5+l5, mj+l5] * U2R_MAT[l6][m6+l6, mk+l6] * g1
            # t1 = time.time()

            if not np.isclose(np.abs(g2), 0):
              assert np.isclose(g2.imag, 0), \
                      'Gaunt coefficients from real spherical harmonics NOT real!' \
                      + f"  G({l4}, {l5}, {l6}, {m4}, {m5}, {m6}) = {g2}"
              ngc += 1
              GAUNT_COEFF_DATA2[k1] = g2
              out.write('   ({:d},{:2d},{:2d}, {:2d},{:2d},{:2d})'.format(*k1) + f' : {g2.real:20.16f},')
              print('Gaunt2({:d},{:2d},{:2d},{:2d},{:2d},{:2d})'.format(*k1) + f' = {v:20.16f} [{t1 - t0:.4f}s]')
              if ngc % 3 == 0:
                out.write('\n')

out.write('}\n\n')


out.write(
'''        

# The array of derivative intergrals.
# 
# :::
# 
#   /  ^    ^   1-l' d   l'    ^
#   | dr Y (r) r     --[r  Y  (r)]
#   /     L           _     L'
#                    dr
#

_ylm_nabla_rlylm = {
  (0,  0, 1, -1): [0.0, 1.7320508075688774, 0.0]
  (0,  0, 1,  0): [0.0, 0.0, 1.7320508075688774]
  (0,  0, 1,  1): [1.7320508075688774, 0.0, 0.0]
  (1, -1, 2, -2): [2.23606797749979, 0.0, 0.0]
  (1, -1, 2, -1): [0.0, 0.0, 2.23606797749979]
  (1, -1, 2,  0): [0.0, -1.2909944487358056, 0.0]
  (1, -1, 2,  2): [0.0, -2.23606797749979, 0.0]
  (1,  0, 2, -1): [0.0, 2.23606797749979, 0.0]
  (1,  0, 2,  0): [0.0, 0.0, 2.581988897471611]
  (1,  0, 2,  1): [2.23606797749979, 0.0, 0.0]
  (1,  1, 2, -2): [0.0, 2.23606797749979, 0.0]
  (1,  1, 2,  0): [-1.2909944487358056, 0.0, 0.0]
  (1,  1, 2,  1): [0.0, 0.0, 2.23606797749979]
  (1,  1, 2,  2): [2.23606797749979, 0.0, 0.0]
  (2, -2, 3, -3): [3.2403703492039297, 0.0, 0.0]
  (2, -2, 3, -2): [0.0, 0.0, 2.6457513110645903]
  (2, -2, 3, -1): [-0.8366600265340757, 0.0, 0.0]
  (2, -2, 3,  1): [0.0, -0.8366600265340757, 0.0]
  (2, -2, 3,  3): [0.0, -3.2403703492039297, 0.0]
  (2, -1, 3, -2): [2.6457513110645903, 0.0, 0.0]
  (2, -1, 3, -1): [0.0, 0.0, 3.3466401061363027]
  (2, -1, 3,  0): [0.0, -2.04939015319192, 0.0]
  (2, -1, 3,  2): [0.0, -2.6457513110645903, 0.0]
  (2,  0, 3, -1): [0.0, 2.8982753492378883, 0.0]
  (2,  0, 3,  0): [0.0, 0.0, 3.5496478698597698]
  (2,  0, 3,  1): [2.8982753492378883, 0.0, 0.0]
  (2,  1, 3, -2): [0.0, 2.6457513110645903, 0.0]
  (2,  1, 3,  0): [-2.04939015319192, 0.0, 0.0]
  (2,  1, 3,  1): [0.0, 0.0, 3.3466401061363027]
  (2,  1, 3,  2): [2.6457513110645903, 0.0, 0.0]
  (2,  2, 3, -3): [0.0, 3.2403703492039297, 0.0]
  (2,  2, 3, -1): [0.0, 0.8366600265340757, 0.0]
  (2,  2, 3,  1): [-0.8366600265340757, 0.0, 0.0]
  (2,  2, 3,  2): [0.0, 0.0, 2.6457513110645907]
  (2,  2, 3,  3): [3.24037034920393, 0.0, 0.0]
}

'''        
)

################################################################################
TABLE_FUNC = '''
def uniq_perm(l1, l2, l3, m1, m2, m3):
    """
    return unique permutation of (l1, l2, l3, m1, m2, m3)
    """

    ii = np.argsort([l1, l2, l3])
    l4, l5, l6 = np.array([l1, l2, l3])[ii]
    m4, m5, m6 = np.array([m1, m2, m3])[ii]

    if l4 == l5 == l6:
        m4, m5, m6 = sorted([m4, m5, m6])
    elif l4 == l5 < l6:
        if m4 > m5:
            m4, m5 = m5, m4
    elif l4 < l5 == l6:
        if m5 > m6:
            m5, m6 = m6, m5
    else:
        pass

    return l4, l5, l6, m4, m5, m6

    
def gaunt_c2r(l1, l2, l3, m1, m2, m3):
    """
    Convert Gaunt coefficients defined on complex SPH to Gaunt coefficients on
    real SPH.
    """

    SQRT2 = np.sqrt(2.0)
    U = []
    M = []
    for m in [m1, m2, m3]:
      if m < 0:
        U.append([1j/SQRT2, -(-1)**(-m) * 1j/SQRT2])
        M.append([m, -m])
      elif m > 0:
        U.append([1/SQRT2,  (-1)**m /SQRT2])
        M.append([-m, m])
      else:
        U.append([1,])
        M.append([0,])

    U  = np.prod(
            np.array(np.meshgrid(U[0], U[1], U[2])).reshape((3, -1)).T,
            axis=1)
    M  = np.array(np.meshgrid(M[0], M[1], M[2])).reshape((3, -1)).T
    g1 = np.array([float(sp.N(gaunt(l1, l2, l3, *m))) for m in M])
    g2 = np.sum(U * g1)

    return g2


def GauntTable(l1=0, l2=0, l3=0, m1=0, m2=0, m3=0, real=True):
    """
    Get Gaunt coefficients from the pre-calculated table.

    If "real = True", the the Gaunt coefficients are defined as the integral
    over three *real* spherical harmonics.
    """

    lmax = np.max([l1, l2, l3])
    assert lmax < GAUNT_LMAX, "Exceeding maximum l in Gaunt Table!"

    # # invariant under any permutation
    # l_sort_ind = np.argsort([l1, l2, l3])
    # l4, l5, l6 = np.array([l1, l2, l3])[l_sort_ind]
    # m4, m5, m6 = np.array([m1, m2, m3])[l_sort_ind]
    # k = (l4, l5, l6, m4, m5, m6)

    k = uniq_perm(l1, l2, l3, m1, m2, m3)

    if real:
        g = 0.0 if k not in GAUNT_COEFF_DATA2 else GAUNT_COEFF_DATA2[k]
    else:
        l4, l5, l6, m4, m5, m6 = k
        # invariant under space reflection
        km = (l4, l5, l6, -m4, -m5, -m6)

        if k in GAUNT_COEFF_DATA1:
            g = GAUNT_COEFF_DATA1[k]
        elif km in GAUNT_COEFF_DATA1:
            g = GAUNT_COEFF_DATA1[km]
        else:
            g = 0.0

    return g


if __name__ == "__main__":
    import sympy as sp
    from sympy.physics.wigner import gaunt

    # for k, v in GAUNT_COEFF_DATA2.items():
    #     # l1, l2, l3, m1, m2, m3 = np.fromstring(k[1:-1], sep=',')
    #     l1, l2, l3, m1, m2, m3 = k
    #     if (l1 + l2 + l3) % 2 != 0:
    #         print(k)
    #     a, b, c = sorted([l1, l2, l3])
    #     if a + b < c:
    #         print(k)
    #     if (m1 + m2 + m3) != 0:
    #         print(k)

    print('Gaunt coefficients from complex SPH:')
    print(GauntTable(4, 3, 1, 2,-3, 1, real=False), sp.N(gaunt(4, 3, 1, 2,-3, 1)))
    print(GauntTable(3, 1, 4,-3, 1, 2, real=False), sp.N(gaunt(3, 1, 4,-3, 1, 2)))
    print(GauntTable(1, 4, 3, 1, 2,-3, real=False), sp.N(gaunt(1, 4, 3, 1, 2,-3)))
    print(GauntTable(3, 4, 1,-3, 2, 1, real=False), sp.N(gaunt(3, 4, 1,-3, 2, 1)))
    print(GauntTable(4, 1, 3, 2, 1,-3, real=False), sp.N(gaunt(4, 1, 3, 2, 1,-3)))
    print(GauntTable(1, 3, 4, 1,-3, 2, real=False), sp.N(gaunt(1, 3, 4, 1,-3, 2)))

    print('Gaunt coefficients from real SPH:')
    print(GauntTable(4, 3, 1,-2,-3,-1), GauntTable(4, 3, 1, 2, 3, 1))
    print(GauntTable(3, 1, 4,-3,-1,-2), GauntTable(3, 1, 4, 3, 1, 2))
    print(GauntTable(1, 4, 3,-1,-2,-3), GauntTable(1, 4, 3, 1, 2, 3))
    print(GauntTable(3, 4, 1,-3,-2,-1), GauntTable(3, 4, 1, 3, 2, 1))
    print(GauntTable(4, 1, 3,-2,-1,-3), GauntTable(4, 1, 3, 2, 1, 3))
    print(GauntTable(1, 3, 4,-1,-3,-2), GauntTable(1, 3, 4, 1, 3, 2))

    print('Gaunt coefficients from real SPH:')
    print(gaunt_c2r(4, 3, 1, 2, 3, 1), GauntTable(4, 3, 1, 2, 3, 1))
    print(gaunt_c2r(3, 1, 4, 3, 1, 2), GauntTable(3, 1, 4, 3, 1, 2))
    print(gaunt_c2r(1, 4, 3, 1, 2, 3), GauntTable(1, 4, 3, 1, 2, 3))
    print(gaunt_c2r(3, 4, 1, 3, 2, 1), GauntTable(3, 4, 1, 3, 2, 1))
    print(gaunt_c2r(4, 1, 3, 2, 1, 3), GauntTable(4, 1, 3, 2, 1, 3))
    print(gaunt_c2r(1, 3, 4, 1, 3, 2), GauntTable(1, 3, 4, 1, 3, 2))
'''

################################################################################
out.write(TABLE_FUNC)
out.close()
################################################################################
