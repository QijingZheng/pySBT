#!/usr/bin/env python

import numpy as np
import sympy as sp
from sympy.physics.wigner import gaunt

def sph_u_c2r(l):
    '''
    Set up transformation matrix complex->real spherical harmonics.

    please refer to:
    https://en.wikipedia.org/wiki/Spherical_harmonics#Real_form
    U_R2C is the conjugate transpose of U_C2R
    '''

    # A strange bug:
    # https://stackoverflow.com/questions/9887549/negative-exponent-with-numpy-array-operand/42776488
    l = int(l)

    TLP1 = 2 * l + 1
    U_C2R = np.zeros((TLP1, TLP1), dtype=complex)

    sqrt2inv = 1.0 / np.sqrt(2.0)
    for ii in range(TLP1):
        M = ii - l
        if (M < 0):
            U_C2R[ii, ii] = 1j * sqrt2inv
            U_C2R[ii, -(ii+1)] = -1j * (-1)**M * sqrt2inv
        if (M == 0):
            U_C2R[ii, ii] = 1.0
        if (M > 0):
            U_C2R[ii, -(ii+1)] = sqrt2inv
            U_C2R[ii, ii] = (-1)**M * sqrt2inv

    return U_C2R

def gaunt_c2r(l1, l2, l3, m1, m2, m3):
    '''
    Convert Gaunt coefficients defined on complex SPH to Gaunt coefficients on
    real SPH.
    '''
    U1 = sph_u_c2r(l1)
    U2 = sph_u_c2r(l2)
    U3 = sph_u_c2r(l3)

    g = 0.0
    for n1 in range(0, 2*l1+1):
      for n2 in range(0, 2*l2+1):
        for n3 in range(0, 2*l3+1):
          if (n1 + n2 + n3 - l1 - l2 - l3) != 0: continue
          g += U1[m1+l1, n1] * U2[m2+l2, n2] * U3[m3+l3, n3] * \
               float(sp.N(gaunt(l1, l2, l3, n1-l1, n2-l2, n3-l3)))
    return g


# Maximum l in Gaunt coefficients
GAUNT_LMAX        = 5
# Gaunt coefficients by integrating three *complex* spherical harmonics
GAUNT_COEFF_DATA1 = {}
# Gaunt coefficients by integrating three *real* spherical harmonics
GAUNT_COEFF_DATA2 = {}
# unitary matrix for transforming complex to real spherical harmonics.
U2R_MAT           = [sph_u_c2r(l) for l in range(GAUNT_LMAX)]

with open('gaunt.py', 'w+') as out:
  out.write('#!/usr/bin/env python\n')
  out.write('# Generated by gen_gaunt_data.py\n\n')
  out.write('import numpy as np\n\n')
  out.write(f'GAUNT_LMAX = {GAUNT_LMAX}\n\n')
  out.write('# (l1, l2, l3, m1, m2, m3) : G\n')
  out.write('GAUNT_COEFF_DATA1 = {\n')

  ngc = 0
  for l1 in range(GAUNT_LMAX):
    for l2 in range(GAUNT_LMAX):
      for l3 in range(GAUNT_LMAX):
  
        # zero for odd sum of ls
        L = l1 + l2 + l3
        if L % 2 != 0: continue
  
        # zero if the triangle inequality not fulfilled
        a, b, c = sorted([l1, l2, l3])
        if a + b < c: continue
  
        for m1 in range(-l1, l1+1):
          for m2 in range(-l2, l2+1):
            for m3 in range(-l3, l3+1):
              # zero if sum of ms not zero
              m = m1 + m2 + m3
              if m != 0: continue

              # invariant under any permutation
              l_sort_ind = np.argsort([l1, l2, l3])
              l4, l5, l6 = np.array([l1, l2, l3])[l_sort_ind]
              m4, m5, m6 = np.array([m1, m2, m3])[l_sort_ind]

              k = f'({l4:2d},{l5:2d},{l6:2d}, {m4:2d},{m5:2d},{m6:2d})'
              if k in GAUNT_COEFF_DATA1: continue

              ngc += 1
              # k = (l1, l2, l3, m1, m2, m3)
              g = sp.N(gaunt(l4, l5, l6, m4, m5, m6))
              v = float(g)
              GAUNT_COEFF_DATA1[k] = v
              out.write(f'   {k} : {v:20.16f},')
              if ngc % 3 == 0:
                out.write('\n')

  out.write('}')
  out.write('\n\n')

  out.write('GAUNT_COEFF_DATA2 = {\n')

  ngc = 0
  for l1 in range(GAUNT_LMAX):
    for l2 in range(GAUNT_LMAX):
      for l3 in range(GAUNT_LMAX):

        # zero for odd sum of ls
        L = l1 + l2 + l3
        if L % 2 != 0: continue
  
        # zero if the triangle inequality not fulfilled
        a, b, c = sorted([l1, l2, l3])
        if a + b < c: continue
  
        for m1 in range(-l1, l1+1):
          for m2 in range(-l2, l2+1):
            for m3 in range(-l3, l3+1):

              # invariant under any permutation
              l_sort_ind = np.argsort([l1, l2, l3])
              l4, l5, l6 = np.array([l1, l2, l3])[l_sort_ind]
              m4, m5, m6 = np.array([m1, m2, m3])[l_sort_ind]

              k1 = f'({l4:2d},{l5:2d},{l6:2d}, {m4:2d},{m5:2d},{m6:2d})'
              if k1 in GAUNT_COEFF_DATA2: continue

              # k1 = f'({l1:2d},{l2:2d},{l3:2d}, {m1:2d},{m2:2d},{m3:2d})'
              # k1 = (l1, l2, l3, m1, m2, m3)

              g2 = 0
              for ii in range(0, 2*l4+1):
                for jj in range(0, 2*l5+1):
                  for kk in range(0, 2*l6+1):
                  
                    k2 = f'({l4:2d},{l5:2d},{l6:2d}, {ii-l4:2d},{jj-l5:2d},{kk-l6:2d})'
                    # k2 = (l1, l2, l3, ii-l1, jj-l2, kk-l3)
                    if k2 not in GAUNT_COEFF_DATA1:
                      continue
                    else:
                      g1 = GAUNT_COEFF_DATA1[k2]

                    # if (ii + jj + kk - l4 - l5 - l6) != 0: continue
                    # g1 = float(sp.N(gaunt(l4, l5, l6, ii-l4, jj-l5, kk-l6)))

                    g2 += U2R_MAT[l4][m4+l4, ii] * U2R_MAT[l5][m5+l5, jj] * U2R_MAT[l6][m6+l6, kk] * g1

              # g2 = gaunt_c2r(l4, l5, l6, m4, m5, m6)

              if not np.isclose(np.abs(g2), 0):
                ngc += 1
                GAUNT_COEFF_DATA2[k1] = g2
                assert np.isclose(g2.imag, 0), \
                        'Gaunt coefficients from real spherical harmonics NOT real!' \
                        + f"  G({l4}, {l5}, {l6}, {m4}, {m5}, {m6}) = {g2}"
                out.write(f'   {k1} : {g2.real:20.16f},')
                if ngc % 3 == 0:
                  out.write('\n')

  out.write('}\n\n')

  TABLE_FUNC = '''
def GauntTable(l1=0, l2=0, l3=0, m1=0, m2=0, m3=0, real=True):
    """
    Get Gaunt coefficients from the pre-calculated table.

    If "real = True", the the Gaunt coefficients are defined as the integral
    over three *real* spherical harmonics.
    """

    lmax = np.max([l1, l2, l3])
    assert lmax < GAUNT_LMAX

    # invariant under any permutation
    l_sort_ind = np.argsort([l1, l2, l3])
    l4, l5, l6 = np.array([l1, l2, l3])[l_sort_ind]
    m4, m5, m6 = np.array([m1, m2, m3])[l_sort_ind]
    k = (l4, l5, l6, m4, m5, m6)

    if real:
        g = 0.0 if k not in GAUNT_COEFF_DATA2 else GAUNT_COEFF_DATA2[k]
    else:
        g = 0.0 if k not in GAUNT_COEFF_DATA1 else GAUNT_COEFF_DATA1[k]

    return g


if __name__ == "__main__":
    for k, v in GAUNT_COEFF_DATA2.items():
        # l1, l2, l3, m1, m2, m3 = np.fromstring(k[1:-1], sep=',')
        l1, l2, l3, m1, m2, m3 = k
        if (l1 + l2 + l3) % 2 != 0:
            print(k)
        a, b, c = sorted([l1, l2, l3])
        if a + b < c:
            print(k)
        if (m1 + m2 + m3) != 0:
            print(k)
    print(
        GauntTable(4, 3, 1, 2, 3, 1),
        GauntTable(3, 1, 4, 3, 1, 2),
        GauntTable(1, 4, 3, 1, 2, 3),
        GauntTable(3, 4, 1, 3, 2, 1),
        GauntTable(4, 1, 3, 2, 1, 3),
        GauntTable(1, 3, 4, 1, 3, 2),
    )
'''

  out.write(TABLE_FUNC)
