#!/usr/bin/env python

################################################################################
import numpy as np
import sympy as sp
from sympy.physics.wigner import gaunt, wigner_3j

from itertools import product
import time

# import sys, logging
# logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)

################################################################################
def sph_u_c2r(l):
    '''
    Set up transformation matrix complex->real spherical harmonics.

    please refer to:
    https://en.wikipedia.org/wiki/Spherical_harmonics#Real_form
    U_R2C is the conjugate transpose of U_C2R
    '''

    # A strange bug:
    # https://stackoverflow.com/questions/9887549/negative-exponent-with-numpy-array-operand/42776488
    l = int(l)

    TLP1 = 2 * l + 1
    U_C2R = np.zeros((TLP1, TLP1), dtype=complex)

    sqrt2inv = 1.0 / np.sqrt(2.0)
    for ii in range(TLP1):
        M = ii - l
        if (M < 0):
            U_C2R[ii, ii] = 1j * sqrt2inv
            U_C2R[ii, -(ii+1)] = -1j * (-1)**M * sqrt2inv
        if (M == 0):
            U_C2R[ii, ii] = 1.0
        if (M > 0):
            U_C2R[ii, -(ii+1)] = sqrt2inv
            U_C2R[ii, ii] = (-1)**M * sqrt2inv

    return U_C2R


def gaunt_c2r(l1, l2, l3, m1, m2, m3):
    '''
    Convert Gaunt coefficients defined on complex SPH to Gaunt coefficients on
    real SPH.
    '''
    U1 = sph_u_c2r(l1)
    U2 = sph_u_c2r(l2)
    U3 = sph_u_c2r(l3)

    g = 0.0
    for n1 in range(0, 2*l1+1):
      for n2 in range(0, 2*l2+1):
        for n3 in range(0, 2*l3+1):
          if (n1 + n2 + n3 - l1 - l2 - l3) != 0: continue
          g += U1[m1+l1, n1] * U2[m2+l2, n2] * U3[m3+l3, n3] * \
               float(sp.N(gaunt(l1, l2, l3, n1-l1, n2-l2, n3-l3)))
    return g


def gaunt3j(l1, l2, l3, m1, m2, m3):
    '''
    Gaunt coefficients from Wigner-3j symbols
    '''


    return sp.N(
      np.sqrt((2*l1+1)*(2*l2+1)*(2*l3+1)/np.pi/4) * \
      wigner_3j(l1, l2, l3, 0, 0, 0) *\
      wigner_3j(l1, l2, l3, m1, m2, m3)
    )


def uniq_perm(l1, l2, l3, m1, m2, m3):
    """
    return unique permutation of (l1, l2, l3, m1, m2, m3)
    """

    ii = np.argsort([l1, l2, l3])
    l4, l5, l6 = np.array([l1, l2, l3])[ii]
    m4, m5, m6 = np.array([m1, m2, m3])[ii]

    if l4 == l5 == l6:
        m4, m5, m6 = sorted([m4, m5, m6])
    elif l4 == l5 < l6:
        if m4 > m5:
            m4, m5 = m5, m4
    elif l4 < l5 == l6:
        if m5 > m6:
            m5, m6 = m6, m5
    else:
        pass
    return l4, l5, l6, m4, m5, m6


################################################################################
# Maximum l in Gaunt coefficients
GAUNT_LMAX        = 7
# Gaunt coefficients by integrating three *complex* spherical harmonics
GAUNT_COEFF_DATA1 = {}
# Gaunt coefficients by integrating three *real* spherical harmonics
GAUNT_COEFF_DATA2 = {}
# unitary matrix for transforming complex to real spherical harmonics.
U2R_MAT           = [sph_u_c2r(l) for l in range(GAUNT_LMAX)]

################################################################################

out = open('kaka.py', 'w+')
out.write('#!/usr/bin/env python\n')
out.write('# Generated by gen_gaunt_data.py\n\n')
out.write('import numpy as np\n\n')
out.write(f'GAUNT_LMAX = {GAUNT_LMAX}\n\n')
out.write('# (l1, l2, l3, m1, m2, m3) : G\n')
out.write('GAUNT_COEFF_DATA1 = {\n')

ngc = 0
for l1 in range(GAUNT_LMAX):
  for l2 in range(GAUNT_LMAX):
    for l3 in range(GAUNT_LMAX):

      # zero for odd sum of ls
      L = l1 + l2 + l3
      if L % 2 != 0: continue

      # zero if the triangle inequality not fulfilled
      a, b, c = sorted([l1, l2, l3])
      if a + b < c: continue

      for m1 in range(-l1, l1+1):
        for m2 in range(-l2, l2+1):
          for m3 in range(-l3, l3+1):
            # zero if sum of ms not zero
            m = m1 + m2 + m3
            if m != 0: continue

            l4, l5, l6, m4, m5, m6 = uniq_perm(l1, l2, l3, m1, m2, m3)
            k  = (l4, l5, l6, m4, m5, m6)
            km = (l4, l5, l6,-m4,-m5,-m6)

            if k in GAUNT_COEFF_DATA1 or km in GAUNT_COEFF_DATA1: continue

            ngc += 1

            # somehow, gaunt(l4, l5, l6, m4, m5, m6) return complex values
            # when l too large
            # g = sp.N(gaunt(l4, l5, l6, m4, m5, m6))
            # v = float(g)

            # resort to wigner-3j method
            g = gaunt3j(l4, l5, l6, m4, m5, m6)
            v = float(g)

            GAUNT_COEFF_DATA1[k] = v
            out.write('   ({:d},{:2d},{:2d}, {:2d},{:2d},{:2d})'.format(*k) + f' : {v:20.16f},')
            print('Gaunt1({:d},{:2d},{:2d},{:2d},{:2d},{:2d})'.format(*k) + f' = {v:20.16f}')
            if ngc % 3 == 0:
              out.write('\n')

out.write('}')
out.write('\n\n')

################################################################################
def GauntTable(l1=0, l2=0, l3=0, m1=0, m2=0, m3=0, real=True):
    """
    Get Gaunt coefficients from the pre-calculated table.

    If "real = True", the the Gaunt coefficients are defined as the integral
    over three *real* spherical harmonics.
    """

    lmax = np.max([l1, l2, l3])
    assert lmax < GAUNT_LMAX, "Exceeding maximum l in Gaunt Table!"

    # # invariant under any permutation
    # l_sort_ind = np.argsort([l1, l2, l3])
    # l4, l5, l6 = np.array([l1, l2, l3])[l_sort_ind]
    # m4, m5, m6 = np.array([m1, m2, m3])[l_sort_ind]
    # k = (l4, l5, l6, m4, m5, m6)

    k = uniq_perm(l1, l2, l3, m1, m2, m3)

    if real:
        g = 0.0 if k not in GAUNT_COEFF_DATA2 else GAUNT_COEFF_DATA2[k]
    else:
        l4, l5, l6, m4, m5, m6 = k
        # invariant under space reflection
        km = (l4, l5, l6, -m4, -m5, -m6)

        if k in GAUNT_COEFF_DATA1:
            g = GAUNT_COEFF_DATA1[k]
        elif km in GAUNT_COEFF_DATA1:
            g = GAUNT_COEFF_DATA1[km]
        else:
            g = 0.0

    return g

################################################################################
out.write('GAUNT_COEFF_DATA2 = {\n')

ngc = 0
for l1 in range(GAUNT_LMAX):
  for l2 in range(GAUNT_LMAX):
    for l3 in range(GAUNT_LMAX):

      # zero for odd sum of ls
      L = l1 + l2 + l3
      if L % 2 != 0: continue

      # zero if the triangle inequality not fulfilled
      l4, l5, l6 = sorted([l1, l2, l3])
      if l4 + l5 < l6: continue

      mijk = np.mgrid[-l4:l4+1, -l5:l5+1, -l6:l6+1].reshape(3, -1).T
      mijk = mijk[np.sum(mijk, axis=1)==0]

      for m1 in range(-l1, l1+1):
        for m2 in range(-l2, l2+1):
          for m3 in range(-l3, l3+1):

            k1 = uniq_perm(l1, l2, l3, m1, m2, m3)
            l4, l5, l6, m4, m5, m6 = k1

            if k1 in GAUNT_COEFF_DATA2: continue

            g2 = 0
            t0 = time.time()
            for ms in mijk:
              mi, mj, mk = ms
              # g1 = float(gaunt3j(l4, l5, l6, mi, mj, mk))
              g1 = GauntTable(l4, l5, l6, mi, mj, mk, real=False)
              g2 += U2R_MAT[l4][m4+l4, mi+l4] * U2R_MAT[l5][m5+l5, mj+l5] * U2R_MAT[l6][m6+l6, mk+l6] * g1
            t1 = time.time()

            if not np.isclose(np.abs(g2), 0):
              ngc += 1
              GAUNT_COEFF_DATA2[k1] = g2
              assert np.isclose(g2.imag, 0), \
                      'Gaunt coefficients from real spherical harmonics NOT real!' \
                      + f"  G({l4}, {l5}, {l6}, {m4}, {m5}, {m6}) = {g2}"
              out.write('   ({:d},{:2d},{:2d}, {:2d},{:2d},{:2d})'.format(*k1) + f' : {g2.real:20.16f},')
              print('Gaunt2({:d},{:2d},{:2d},{:2d},{:2d},{:2d})'.format(*k1) + f' = {v:20.16f} [{t1 - t0:.4f}s]')
              if ngc % 3 == 0:
                out.write('\n')

out.write('}\n\n')

################################################################################
TABLE_FUNC = '''
def uniq_perm(l1, l2, l3, m1, m2, m3):
    """
    return unique permutation of (l1, l2, l3, m1, m2, m3)
    """

    ii = np.argsort([l1, l2, l3])
    l4, l5, l6 = np.array([l1, l2, l3])[ii]
    m4, m5, m6 = np.array([m1, m2, m3])[ii]

    if l4 == l5 == l6:
        m4, m5, m6 = sorted([m4, m5, m6])
    elif l4 == l5 < l6:
        if m4 > m5:
            m4, m5 = m5, m4
    elif l4 < l5 == l6:
        if m5 > m6:
            m5, m6 = m6, m5
    else:
        pass

    return l4, l5, l6, m4, m5, m6

    
def GauntTable(l1=0, l2=0, l3=0, m1=0, m2=0, m3=0, real=True):
    """
    Get Gaunt coefficients from the pre-calculated table.

    If "real = True", the the Gaunt coefficients are defined as the integral
    over three *real* spherical harmonics.
    """

    lmax = np.max([l1, l2, l3])
    assert lmax < GAUNT_LMAX, "Exceeding maximum l in Gaunt Table!"

    # # invariant under any permutation
    # l_sort_ind = np.argsort([l1, l2, l3])
    # l4, l5, l6 = np.array([l1, l2, l3])[l_sort_ind]
    # m4, m5, m6 = np.array([m1, m2, m3])[l_sort_ind]
    # k = (l4, l5, l6, m4, m5, m6)

    k = uniq_perm(l1, l2, l3, m1, m2, m3)

    if real:
        g = 0.0 if k not in GAUNT_COEFF_DATA2 else GAUNT_COEFF_DATA2[k]
    else:
        l4, l5, l6, m4, m5, m6 = k
        # invariant under space reflection
        km = (l4, l5, l6, -m4, -m5, -m6)

        if k in GAUNT_COEFF_DATA1:
            g = GAUNT_COEFF_DATA1[k]
        elif km in GAUNT_COEFF_DATA1:
            g = GAUNT_COEFF_DATA1[km]
        else:
            g = 0.0

    return g


if __name__ == "__main__":
    for k, v in GAUNT_COEFF_DATA2.items():
        # l1, l2, l3, m1, m2, m3 = np.fromstring(k[1:-1], sep=',')
        l1, l2, l3, m1, m2, m3 = k
        if (l1 + l2 + l3) % 2 != 0:
            print(k)
        a, b, c = sorted([l1, l2, l3])
        if a + b < c:
            print(k)
        if (m1 + m2 + m3) != 0:
            print(k)
    print(
        GauntTable(4, 3, 1, 2, 3, 1),
        GauntTable(3, 1, 4, 3, 1, 2),
        GauntTable(1, 4, 3, 1, 2, 3),
        GauntTable(3, 4, 1, 3, 2, 1),
        GauntTable(4, 1, 3, 2, 1, 3),
        GauntTable(1, 3, 4, 1, 3, 2),
    )
    print(
        GauntTable(4, 3, 1, 2,-3, 1, real=False),
        GauntTable(3, 1, 4,-3, 1, 2, real=False),
        GauntTable(1, 4, 3, 1, 2,-3, real=False),
        GauntTable(3, 4, 1,-3, 2, 1, real=False),
        GauntTable(4, 1, 3, 2, 1,-3, real=False),
        GauntTable(1, 3, 4, 1,-3, 2, real=False),
    )
'''

################################################################################
out.write(TABLE_FUNC)
out.close()
################################################################################
